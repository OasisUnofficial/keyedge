* Steps and Workflow

  * `ocalls.h` (script looks for this file), this is inside the enclave
    - function signatures
    - `ocalls_header.h` (this has declarations for keyedge datatypes, 
    e.g., keyedge str, var length arrays)
    - can also include program-specific struct headers (so `mystruct.h`)
    - what happens if `mystruct.h` has a string or a car length array
    
  * `host.c` (defines the function, is outside the enclave, in the host)
    - includes ocalls_host.h (this file is auto-generated by our tool)
    - the function definition need not use any of the keyedge str and so on
    - need to invoke `register_functions()` before init of the enclave
      - this is something that keystone does even without keyedge
      - specifically this is the call bridge / function table, takes 
      the number and jumps to the function
  
  * Make file changes
    *  vault
    - new keyedge vault
    - processes ocalls.h and invokes flatcc
    - keyedge goes before building host and enclave binaries

  * Tool Steps
    * keyedge processing 
      - first assemble user defined functions for ocalls
      - use `ocalls.h` to generate 4 files
      - `main.cpp` in keyedge
        * `parser.cpp`
          - takes the input, invokes clang, creates an AST, 
          - walk through the AST, collect function name, signature, struct
          - store them in custom data structs
        * `emitter.cpp`
          - goes through our custom data structs
          - creates 4 files (cout, ofstream based)
            * `ocalls.fbs`
              - flatcc file, has function info in flatcc format
            * `ocalls_common.h`
              - has declarations that both enclave and host uses, has 
                the bridge containing the function call numbers from the 
                function table
            * ocalls_eapp.h 
              - has declaration and implementation
              * template looks like this:
                - serialize all args from enclave
                - perform the call
                - deserialize the return
                - free the input serialization buffer
                - uses flatcc format for all this
                - cant free the return value buffer
                - for now the output buffer is 1KB in size
                - because we have not computed the return size before 
                  hand
                - we can improve this by having a pre-computed size 
                for each known datatype for flatcc
            * `ocalls_host.h`
              - has declaration and implementation
              * 3 steps:
                - parse input, we have the input buffer pointer as the 
                input to the function
                - invoke function
                - write values to a new buffer
                - copy flatcc values from that to shared buf
              - it knows the output shared buffer address provided by 
                keystone by calling `edge_call_data_ptr()`
              - wrapper to invoke the function in the host
              - has input from memory, doesn't return, because flatcc
              - can be improved: reduce number of copies from 4 to 2?
              - checks are missing at the moment, we just use the size 
                provided in the call
              - also has the function definition for `register_functions()`
        * flatcc (from the build script)
          - tell flatcc that here is the fbs file
          * creates 5 files
            * `ocall_reader.h`, `ocall_builder.h`
              - when we read something (deserialize) or build a flatcc 
                struct (serialize), we need to include these file
              - we include this in `ocall_eapps.h` and `ocall_host.h`
            * `ocall_verifier.h`
              - if a buffer is readable or in the right format
              - not being used yet, we should use it at least inside 
                the enclave for safety
            * `flatbuffers_common_reader.h`
              - included in `ocall_reader.h`
              - keyedge does not include this explicitly anywhere
            * `flatbuffers_common_builder.h`
              - included in the `ocall_builder.h`
              - keyedge does not include this explicitly anywhere
        * flatcc runtime libraries
          - when we run top level make, it generates these libaries, 
            use risc-v gcc toolchain
          * `flatccrt.a` 
            - src/runtime: `builder.c`, `emitter.c`, `refmap.c`, `verifier.c`
            - use libc functions such as `realloc`, `malloc` (see 
              slack list for details)
            * 5 functions: `strcmp`, `strncmp`, `_assert_fail`, 
              `memchr`, `posix_memalign` 
              - these are not implemented in eyrie rt, so we have 
                added our own implementation (taken from the Internet) 
                for these
              - `comman_header.h` has it
              - this file is included in the `eapp.c`
              - need to move these implementations to eyrie RT
            - need these for linking `flatccrt.a` 
      * linking step
            - generates the same things as the vault (eyrie, eapp, host)
  
  * Testing with demo
    * make
      - does not use vault
      - demo has multiple files, not as simple as `host.c` and `eapp.c`
      - some issues with the base-offset and parameters
      - missing checks in our keyedge version at the moment
    * interesting signatures we have in this case are
      - inputs
        - strings for print buffer 
        - variable length arrays of different types for sending reports
      - return 
        - fixed size array for public key 
        - variable length return for input message
